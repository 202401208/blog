# 알고리즘의 실행시간을 측정해 보자.
알고리즘의 효율성은 계산속도와 메모리 사용량으로 평가할 수 있다. 즉, 좋은 알고리즘은 실행시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 것이다. 일반적으로 실행시간이 메모리 공간보다 더 중요하게 인식되므로 실행시간을 효율적인 알고리즘의 기준으로 삼는다.


```python
import time
```

시각 측정 함수를 사용하기 위해 time 모듈을 프로그램에 포함시킴.


```python
mybag = []
```


```python
start = time.time()
```

현재 시각을 start에 저장(알고리즘 처리 전)


```python
mybag.append('축구공')  
...
```

실행시간을 측정하려는 코드(알고리즘)가 들어가는 부분


```python
end = time.time()
```

현재 시각을 end에 저장(종료 시각)


```python
print("실행시간=", end-start)
```

    실행시간= 0.5851290225982666
    

알고리즘의 전체 실행시간(end-start)

### time 모듈

파이썬은 다양한 모듈을 제공하는데, 모듈을 사용하기 위해서는 먼저 import로 모듈을 코드에 포함해야 한다. time 모듈은 운영체제가 제공하는 다양한 시간 관련 기능을 제공하는데, time.time()은 컴퓨터의 현재 시각을 반환하는 함수이다.

# 알고리즘의 복잡도 분석이란?
알고리즘의 복잡도 분석(complexity analysis)은 구현하지 않고 알고리즘의 효율성을 평가하는 방법이다. 처리시간을 직접 측정하는 것이 아니라 알고리즘의 연산 횟수를 대략적으로 계산하는데, 더 많은 연산이 필요하면 더 복잡한 알고리즘이 된다. 물론 복잡하지 않은 알고리즘이 더 좋은 알고리즘이다.  

예를 들어 자연수 1부터 n까지의 합을 구하는 두 가지 알고리즘을 생각 해보자.

### 알고리즘 1.1(반복을 이용해 1부터 n까지 합을 구함)


```python
def calc_sum1(n):
    sum = 0 # 연산자 1번 수행
    for i in range(1, n+1): # 반복 제어 연산은 무시
        sum = sum + i # n번 반복되는 반복문 안에 있으므로 = 연산자와 + 연산자가 각각 n번씩 수행
    return sum
```

복잡도 함수는 T(n) = 2n + 1

### 알고리즘 1.2(합 공식으로부터 1부터 n까지 합을 구함)


```python
def calc_sum2(n):
    sum = n * (n + 1) / 2 # = 연산자와 *, +, / 연산자가 각각 1번씩 수행
    return sum
```

복잡도 함수는 T(n) = 4
