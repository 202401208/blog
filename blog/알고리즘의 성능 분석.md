# 알고리즘의 실행시간을 측정해 보자.
알고리즘의 효율성은 계산속도와 메모리 사용량으로 평가할 수 있다. 즉, 좋은 알고리즘은 실행시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 것이다. 일반적으로 실행시간이 메모리 공간보다 더 중요하게 인식되므로 실행시간을 효율적인 알고리즘의 기준으로 삼는다.


```python
import time
```

시각 측정 함수를 사용하기 위해 time 모듈을 프로그램에 포함시킴.


```python
mybag = []
```


```python
start = time.time()
```

현재 시각을 start에 저장(알고리즘 처리 전)


```python
mybag.append('축구공')  
...
```

실행시간을 측정하려는 코드(알고리즘)가 들어가는 부분


```python
end = time.time()
```

현재 시각을 end에 저장(종료 시각)


```python
print("실행시간=", end-start)
```

    실행시간= 0.021242141723632812
    

알고리즘의 전체 실행시간(end-start)

### time 모듈

파이썬은 다양한 모듈을 제공하는데, 모듈을 사용하기 위해서는 먼저 import로 모듈을 코드에 포함해야 한다. time 모듈은 운영체제가 제공하는 다양한 시간 관련 기능을 제공하는데, time.time()은 컴퓨터의 현재 시각을 반환하는 함수이다.

# 알고리즘의 복잡도 분석이란?
알고리즘의 복잡도 분석(complexity analysis)은 구현하지 않고 알고리즘의 효율성을 평가하는 방법이다. 처리시간을 직접 측정하는 것이 아니라 알고리즘의 연산 횟수를 대략적으로 계산하는데, 더 많은 연산이 필요하면 더 복잡한 알고리즘이 된다. 물론 복잡하지 않은 알고리즘이 더 좋은 알고리즘이다.  

예를 들어 자연수 1부터 n까지의 합을 구하는 두 가지 알고리즘을 생각 해보자.

### 알고리즘 1.1(반복을 이용해 1부터 n까지 합을 구함)


```python
def calc_sum1(n):
    sum = 0 # 연산자 1번 수행
    for i in range(1, n+1): # 반복 제어 연산은 무시
        sum = sum + i # n번 반복되는 반복문 안에 있으므로 = 연산자와 + 연산자가 각각 n번씩 수행
    return sum
```

복잡도 함수는 T(n) = 2n + 1

### 알고리즘 1.2(합 공식으로부터 1부터 n까지 합을 구함)


```python
def calc_sum2(n):
    sum = n * (n + 1) / 2 # = 연산자와 *, +, / 연산자가 각각 1번씩 수행
    return sum
```

복잡도 함수는 T(n) = 4

알고리즘 1.2는 크기 n과 관계없이 항상 같은 연산이 수행되는 데 비해, 알고리즘 1.1은 n에 비례하는 수의 연산이 실행된다. 이들을 그래프로 비교하면 다음과 같다.

![그래프.png](6c59ef1c-1fef-463a-99ee-f79c623d5788.png)

그래프를 보면 두 알고리즘의 차이가 확실하게 나타나는데, n이 커질수록 알고리즘 1.2가 알고리즘 1.1보다 효율적이라는 것을 알 수 있다.

# 복잡도의 점근적 표기

알고리즘의 복잡도는 흔히 더 간단한 형태로 단순화하여 사용한다. 예를 들어 알고리즘 1.1의 복잡도를 2n+1이 아니라 n이라 말하고, T(n)이 8n²+2n+17이면 n²이라고 말하는 식이다.

예를 들어 n개의 숫자를 정렬하는 알고리즘 A와 B가 있는데, 이들의 복잡도 함수가 각각 Ta(n)=65536n+2000000와 Tb(n)=n²+2n라고 가정하자. 알고리즘 A의 복잡도는 n, B의 복잡도는 n²으로 단순하게 나타내는 것이다. 이러한 표현 방법을 점근적 표기(asymptotic notation)라고 부른다.

# 빅오(big-O) 표기법

빅오 표기법은 알고리즘의 복잡도를 O(g(n))과 같이 나타내는데, 이것은 증가속도가 g(n)과 같거나 낮은 모든 복잡도 함수를 모두 포함한다. 예를 들어, 복잡도 함수가 2n+1이면, 이 알고리즘은 "O(n)에 속한다" 또는 "O(n)이다"라고 말할 수 있는데, 2n+1의 증가속도가 n과 같기 때문이다. 반대로 0.000001n³인 알고리즘은 아무리 계수가 작아지더라도 절대로 O(n²)에 속할 수 없는데, 증가속도가 n³로 n²보다 빠르기 떄문이다. O(n²)은 어떤 경우에도 n²에 비례하는 시간 안에는 반드시 완료된다는 것을 말하는데, n²보다 더 빨리 처리될 수는 있지만 절대로 그보다 시간이 더 걸릴 수는 없다.

![시간복잡도함수.png](8ed019c4-f98c-4c0e-a556-fce5114b36f7.png)

상수형인 O(1)은 n이 변하더라도 항상 일정한 시간에 처리되는 가장 빠른 알고리즘이고, O(n)은 n에 비례하는 시간이 걸리기 때문에 선형시간이라 부른다. O(2ⁿ)은 지수형, O(n!)은 팩토리얼형이라 부르는데, 이들은 입력이 수십 개만 되어도 엄청난 시간이 요구되어 현실적이지 않은 가장 나쁜 알고리즘이다.

# 복잡도 분석의 예

배열에서 어떤 값의 위치를 찾는 알고리즘을 만들어 보고 복잡도를 분석해 보자. 찾는 값이 어디에 있는지 알 수 없으므로 첫 번째 항목부터 순서대로 검사해야 하는데, 만약 찾는 항목이 있으면 그 위치를 반환하고, 없으면 -1을 반환한다. 순차 탐색이라고 불리는 이 알고리즘은 다음과 같이 파이썬으로 구현할 수 있다.

### 코드 1.4 순차 탐색 함수


```python
def search(A, key): # 배열 A에서 key인 항목을 찾는 함수
    n = len(A) # 알고리즘의 입력의 크기는 배열A의 크기
    for i in range(n): # i에 0부터 n-1까지 순서대로 대입
        if A[i] == key: # key인 항목을 찾으면 인덱스 i 반환, 4행이 가장 많이 수행됨(n번)
            return i
        return -1 # A에 key가 없으면(탐색 실패) -1반환
```

복잡도 분석을 위해서는 먼저 입력의 크기와 가장 많이 수행되는 기준 연산을 찾아야 한다. 코드 1.4에서 입력의 크기와 기준 연산을 찾아보자.

* 3행의 반복문은 배열의 크기만큼 수행된다. 따라서 입력의 크기는 배열의 크기(n)이다. 찾을 값 key가 더 크다고 해서 더 많은 연산이 수행되지는 않는다.
* 가장 많이 수행되는 연산은 무엇일까? 2행은 n과 산관없이 한번, 5행과 6행도 조건이 되는 경우에만 한 번 수행된다. 4행은 어떨까?  for문이 반복될 때마다 한 번씩 수행괸다. 따라서 4행의 == 연산의 수행 횟수를 기준으로 복잡도를 분석하면 된다.

그런데 이 알고리즘은 입력의 크기가 같더라도 입력의 구성이 다르면 처리시간이 달라지는 알고리즘이다. 결국 이 알고리즘의 시간 복잡도는 최선의 경우 O(1), 최악이나 평균적인 경우 O(n)이다. 
